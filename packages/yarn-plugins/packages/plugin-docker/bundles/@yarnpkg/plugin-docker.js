/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-docker",
factory: function (require) {
"use strict";var plugin=(()=>{var L=Object.defineProperty;var Q=Object.getOwnPropertyDescriptor;var Z=Object.getOwnPropertyNames;var tt=Object.prototype.hasOwnProperty;var ot=(e,o,t)=>o in e?L(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t;var n=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(o,t)=>(typeof require<"u"?require:o)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var et=(e,o)=>{for(var t in o)L(e,t,{get:o[t],enumerable:!0})},rt=(e,o,t,r)=>{if(o&&typeof o=="object"||typeof o=="function")for(let i of Z(o))!tt.call(e,i)&&i!==t&&L(e,i,{get:()=>o[i],enumerable:!(r=Q(o,i))||r.enumerable});return e};var it=e=>rt(L({},"__esModule",{value:!0}),e);var C=(e,o,t)=>(ot(e,typeof o!="symbol"?o+"":o,t),t);var pt={};et(pt,{default:()=>ct});var X=n("@yarnpkg/cli"),d=n("@yarnpkg/core"),w=n("@yarnpkg/fslib"),K=n("@yarnpkg/plugin-patch"),h=n("clipanion");var u=n("@yarnpkg/fslib");function at(e,o){let t=u.npath.toPortablePath(o);return u.ppath.isAbsolute(t)?u.ppath.relative(e,t):t}async function W({destination:e,files:o,buildDir:t,report:r}){let i=u.ppath.dirname(t);for(let a of o){let f=at(i,a),s=u.ppath.join(i,f),p=u.ppath.join(e,f);r.reportInfo(null,f),await u.xfs.copyPromise(p,s)}}var b=n("@yarnpkg/fslib"),$=n("@yarnpkg/core");async function I({destination:e,project:o,cache:t,report:r}){for(let i of t.markedFiles){let a=b.ppath.relative(o.cwd,i);await b.xfs.existsPromise(i)?(r.reportInfo(null,a),await b.xfs.copyPromise(b.ppath.join(e,a),i)):r.reportWarning($.MessageName.UNUSED_CACHE_ENTRY,a)}}var k=n("@yarnpkg/fslib"),z=n("@yarnpkg/core");async function S({destination:e,workspaces:o,report:t}){for(let r of o){let i=k.ppath.join(r.relativeCwd,z.Manifest.fileName),a=k.ppath.join(e,i),f={};r.manifest.exportTo(f),t.reportInfo(null,i),await k.xfs.mkdirpPromise(k.ppath.dirname(a)),await k.xfs.writeJsonPromise(a,f)}}var j=n("@yarnpkg/fslib");async function T({destination:e,project:o,report:t}){let r=j.ppath.join(".yarn","plugins");t.reportInfo(null,r),await j.xfs.copyPromise(j.ppath.join(e,r),j.ppath.join(o.cwd,r),{overwrite:!0})}var M=n("@yarnpkg/core"),P=n("@yarnpkg/fslib"),st=/^builtin<([^>]+)>$/;async function U({destination:e,report:o,project:t,parseDescriptor:r}){let i=new Set;for(let a of t.storedDescriptors.values()){let f=M.structUtils.isVirtualDescriptor(a)?M.structUtils.devirtualizeDescriptor(a):a,s=r(f);if(!s)continue;let{parentLocator:p,paths:c}=s;for(let y of c){if(st.test(y)||P.ppath.isAbsolute(y))continue;let m=t.getWorkspaceByLocator(p),l=P.ppath.join(m.relativeCwd,y);if(i.has(l))continue;i.add(l);let F=P.ppath.join(m.cwd,y),V=P.ppath.join(e,l);o.reportInfo(null,l),await P.xfs.mkdirpPromise(P.ppath.dirname(V)),await P.xfs.copyFilePromise(F,V)}}}var v=n("@yarnpkg/fslib");async function A({destination:e,project:o,report:t}){let r=o.configuration.get("rcFilename");t.reportInfo(null,r),await v.xfs.copyPromise(v.ppath.join(e,r),v.ppath.join(o.cwd,r),{overwrite:!0})}var R=n("@yarnpkg/fslib");async function E({destination:e,project:o,report:t}){let r=o.configuration.get("yarnPath");if(!r)return;let i=R.ppath.relative(o.cwd,r),a=R.ppath.join(e,i);t.reportInfo(null,i),await R.xfs.copyPromise(a,r,{overwrite:!0})}var N=n("@yarnpkg/core"),G=n("@yarnpkg/fslib");function H(e){let{params:o,selector:t}=N.structUtils.parseRange(e),r=G.npath.toPortablePath(t);return{parentLocator:o&&typeof o.locator=="string"?N.structUtils.parseLocator(o.locator):null,path:r}}var x=n("@yarnpkg/fslib");async function q({destination:e,project:o,report:t}){let r="yarn.lock",i=x.ppath.join(e,r);t.reportInfo(null,r),await x.xfs.mkdirpPromise(x.ppath.dirname(i)),await x.xfs.writeFilePromise(i,o.generateLockfile())}var J=n("@yarnpkg/core");function B({project:e,workspaces:o,production:t=!1,scopes:r=t?["dependencies"]:J.Manifest.hardDependencies}){let i=new Set([...o]);for(let a of i)for(let f of r){let s=a.manifest.getForScope(f).values();for(let p of s){let c=e.tryWorkspaceByDescriptor(p);c&&i.add(c)}}for(let a of e.workspaces)i.has(a)?t&&a.manifest.devDependencies.clear():(a.manifest.dependencies.clear(),a.manifest.devDependencies.clear(),a.manifest.peerDependencies.clear());return i}var O=n("@yarnpkg/core"),D=n("@yarnpkg/fslib"),Y=n("@yarnpkg/plugin-pack");async function _({workspace:e,destination:o,manifestDir:t,report:r}){await Y.packUtils.prepareForPack(e,{report:r},async()=>{let i=await Y.packUtils.genPackList(e),a=O.Report.progressViaCounter(i.length),f=r.reportProgress(a);try{for(let s of i){let p=D.ppath.join(e.cwd,s);if(p.startsWith(t))continue;let c=D.ppath.join(o,e.relativeCwd,s);r.reportInfo(null,s),await D.xfs.copyPromise(c,p,{overwrite:!0}),a.tick()}}finally{f.stop()}})}var g=class extends X.BaseCommand{workspaceName=h.Option.String();buildDir=h.Option.String("-d,--dir","build");copyPackFiles=h.Option.Array("-cp,--copy-pack");copyManifestFiles=h.Option.Array("-cm,--copy-manifest");production=h.Option.Boolean("-p,--production");async execute(){let o=await d.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await d.Project.find(o,this.context.cwd),r=t.getWorkspaceByIdent(d.structUtils.parseIdent(this.workspaceName)),i=B({project:t,workspaces:[r],production:this.production}),a=await d.Cache.find(o);return(await d.StreamReport.start({configuration:o,stdout:this.context.stdout,includeLogs:!this.context.quiet},async s=>{await s.startTimerPromise("Resolution Step",async()=>{await t.resolveEverything({report:s,cache:a})}),await s.startTimerPromise("Fetch Step",async()=>{await t.fetchEverything({report:s,cache:a})});let p=w.ppath.join(this.context.cwd,w.npath.toPortablePath(this.buildDir));await s.startTimerPromise("Remove previous build",async()=>{await w.xfs.removePromise(p,{recursive:!0})});let c=w.ppath.join(p,"manifests"),y=w.ppath.join(p,"packs");await s.startTimerPromise("Copy files",async()=>{await A({destination:c,project:t,report:s}),await T({destination:c,project:t,report:s}),await E({destination:c,project:t,report:s}),await S({destination:c,workspaces:t.workspaces,report:s}),await U({destination:c,report:s,project:t,parseDescriptor:m=>{if(m.range.startsWith("exec:")){let l=H(m.range);return l?.parentLocator?{parentLocator:l.parentLocator,paths:[l.path]}:void 0}else if(m.range.startsWith("patch:")){let{parentLocator:l,patchPaths:F}=K.patchUtils.parseDescriptor(m);return l?{parentLocator:l,paths:F}:void 0}}}),await I({destination:c,project:t,cache:a,report:s}),await q({destination:c,project:t,report:s}),this.copyManifestFiles?.length&&await W({destination:c,files:this.copyManifestFiles,buildDir:p,report:s})});for(let m of i){let l=m.manifest.name?d.structUtils.stringifyIdent(m.manifest.name):"";await s.startTimerPromise(`Pack workspace ${l}`,async()=>{await _({workspace:m,report:s,destination:y,manifestDir:c})})}this.copyPackFiles?.length&&await W({destination:y,files:this.copyPackFiles,buildDir:p,report:s})})).exitCode()}};C(g,"usage",h.Command.Usage({category:"Docker-related commands",description:"Pack a workspace for Docker",details:`
      This command will pack a build dir which only contains required dependencies for the specified workspace.

      You can copy additional files or folders using the "--copy-pack/manifest" option. This is useful for secret keys or configuration files. The files will be copied to either the "manifests" or "packs" folders. The path can be either a path relative to the build dir or an absolute path.
    `,examples:[["Pack a workspace for Docker","yarn docker pack @foo/bar"],["Copy additional files","yarn docker pack --copy-pack secret.key --copy-manifest config.json @foo/bar"]]})),C(g,"paths",[["docker","pack"]]);var nt={commands:[g]},ct=nt;return it(pt);})();
return plugin;
}
};
