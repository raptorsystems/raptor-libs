/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-docker",
factory: function (require) {
"use strict";var plugin=(()=>{var W=Object.defineProperty;var Z=Object.getOwnPropertyDescriptor;var tt=Object.getOwnPropertyNames;var ot=Object.prototype.hasOwnProperty;var et=(e,t,o)=>t in e?W(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o;var n=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,o)=>(typeof require<"u"?require:t)[o]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var rt=(e,t)=>{for(var o in t)W(e,o,{get:t[o],enumerable:!0})},it=(e,t,o,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of tt(t))!ot.call(e,i)&&i!==o&&W(e,i,{get:()=>t[i],enumerable:!(r=Z(t,i))||r.enumerable});return e};var at=e=>it(W({},"__esModule",{value:!0}),e);var I=(e,t,o)=>(et(e,typeof t!="symbol"?t+"":t,o),o);var lt={};rt(lt,{default:()=>pt});var X=n("@yarnpkg/cli"),d=n("@yarnpkg/core"),m=n("@yarnpkg/fslib"),K=n("@yarnpkg/plugin-patch"),g=n("clipanion");var P=n("@yarnpkg/fslib");function st(e,t){let o=P.npath.toPortablePath(t);return P.ppath.isAbsolute(o)?P.ppath.relative(e,o):o}async function C({destination:e,files:t,buildDir:o,report:r}){let i=P.ppath.dirname(o);for(let a of t){let l=st(i,a),s=P.ppath.join(i,l),p=P.ppath.join(e,l);r.reportInfo(null,l),await P.xfs.copyPromise(p,s)}}var v=n("@yarnpkg/fslib"),$=n("@yarnpkg/core");async function S({destination:e,project:t,cache:o,report:r}){for(let i of o.markedFiles){let a=v.ppath.relative(t.cwd,i);await v.xfs.existsPromise(i)?(r.reportInfo(null,a),await v.xfs.copyPromise(v.ppath.join(e,a),i)):r.reportWarning($.MessageName.UNUSED_CACHE_ENTRY,a)}}var j=n("@yarnpkg/fslib"),z=n("@yarnpkg/core");async function T({destination:e,workspaces:t,report:o}){for(let r of t){let i=j.ppath.join(r.relativeCwd,z.Manifest.fileName),a=j.ppath.join(e,i),l={};r.manifest.exportTo(l),o.reportInfo(null,i),await j.xfs.mkdirpPromise(j.ppath.dirname(a)),await j.xfs.writeJsonPromise(a,l)}}var h=n("@yarnpkg/fslib");async function M({destination:e,project:t,report:o}){let r=h.ppath.join((0,h.toFilename)(".yarn"),(0,h.toFilename)("plugins"));o.reportInfo(null,r),await h.xfs.copyPromise(h.ppath.join(e,r),h.ppath.join(t.cwd,r),{overwrite:!0})}var U=n("@yarnpkg/core"),w=n("@yarnpkg/fslib"),nt=/^builtin<([^>]+)>$/;async function A({destination:e,report:t,project:o,parseDescriptor:r}){let i=new Set;for(let a of o.storedDescriptors.values()){let l=U.structUtils.isVirtualDescriptor(a)?U.structUtils.devirtualizeDescriptor(a):a,s=r(l);if(!s)continue;let{parentLocator:p,paths:c}=s;for(let b of c){if(nt.test(b)||w.ppath.isAbsolute(b))continue;let R=o.getWorkspaceByLocator(p),f=w.ppath.join(R.relativeCwd,b);if(i.has(f))continue;i.add(f);let y=w.ppath.join(R.cwd,b),u=w.ppath.join(e,f);t.reportInfo(null,f),await w.xfs.mkdirpPromise(w.ppath.dirname(u)),await w.xfs.copyFilePromise(y,u)}}}var D=n("@yarnpkg/fslib");async function E({destination:e,project:t,report:o}){let r=t.configuration.get("rcFilename");o.reportInfo(null,r),await D.xfs.copyPromise(D.ppath.join(e,r),D.ppath.join(t.cwd,r),{overwrite:!0})}var F=n("@yarnpkg/fslib");async function N({destination:e,project:t,report:o}){let r=t.configuration.get("yarnPath"),i=F.ppath.relative(t.cwd,r),a=F.ppath.join(e,i);o.reportInfo(null,i),await F.xfs.copyPromise(a,r,{overwrite:!0})}var q=n("@yarnpkg/core"),G=n("@yarnpkg/fslib");function H(e){let{params:t,selector:o}=q.structUtils.parseRange(e),r=G.npath.toPortablePath(o);return{parentLocator:t&&typeof t.locator=="string"?q.structUtils.parseLocator(t.locator):null,path:r}}var k=n("@yarnpkg/fslib");async function B({destination:e,project:t,report:o}){let r=(0,k.toFilename)(t.configuration.get("lockfileFilename")),i=k.ppath.join(e,r);o.reportInfo(null,r),await k.xfs.mkdirpPromise(k.ppath.dirname(i)),await k.xfs.writeFilePromise(i,t.generateLockfile())}var J=n("@yarnpkg/core");function Y({project:e,workspaces:t,production:o=!1,scopes:r=o?["dependencies"]:J.Manifest.hardDependencies}){let i=new Set([...t]);for(let a of i)for(let l of r){let s=a.manifest.getForScope(l).values();for(let p of s){let c=e.tryWorkspaceByDescriptor(p);c&&i.add(c)}}for(let a of e.workspaces)i.has(a)?o&&a.manifest.devDependencies.clear():(a.manifest.dependencies.clear(),a.manifest.devDependencies.clear(),a.manifest.peerDependencies.clear());return i}var O=n("@yarnpkg/core"),L=n("@yarnpkg/fslib"),_=n("@yarnpkg/plugin-pack");async function V({workspace:e,destination:t,manifestDir:o,report:r}){await _.packUtils.prepareForPack(e,{report:r},async()=>{let i=await _.packUtils.genPackList(e),a=O.Report.progressViaCounter(i.length),l=r.reportProgress(a);try{for(let s of i){let p=L.ppath.join(e.cwd,s);if(p.startsWith(o))continue;let c=L.ppath.join(t,e.relativeCwd,s);r.reportInfo(null,s),await L.xfs.copyPromise(c,p,{overwrite:!0}),a.tick()}}finally{l.stop()}})}var x=class extends X.BaseCommand{workspaceName=g.Option.String();buildDir=g.Option.String("-d,--dir","build");copyPackFiles=g.Option.Array("-cp,--copy-pack");copyManifestFiles=g.Option.Array("-cm,--copy-manifest");production=g.Option.Boolean("-p,--production");async execute(){let t=await d.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await d.Project.find(t,this.context.cwd),r=o.getWorkspaceByIdent(d.structUtils.parseIdent(this.workspaceName)),i=Y({project:o,workspaces:[r],production:this.production}),a=await d.Cache.find(t);return(await d.StreamReport.start({configuration:t,stdout:this.context.stdout,includeLogs:!this.context.quiet},async s=>{var R;await s.startTimerPromise("Resolution Step",async()=>{await o.resolveEverything({report:s,cache:a})}),await s.startTimerPromise("Fetch Step",async()=>{await o.fetchEverything({report:s,cache:a})});let p=m.ppath.join(this.context.cwd,m.npath.toPortablePath(this.buildDir));await s.startTimerPromise("Remove previous build",async()=>{await m.xfs.removePromise(p,{recursive:!0})});let c=m.ppath.join(p,(0,m.toFilename)("manifests")),b=m.ppath.join(p,(0,m.toFilename)("packs"));await s.startTimerPromise("Copy files",async()=>{var f;await E({destination:c,project:o,report:s}),await M({destination:c,project:o,report:s}),await N({destination:c,project:o,report:s}),await T({destination:c,workspaces:o.workspaces,report:s}),await A({destination:c,report:s,project:o,parseDescriptor:y=>{if(y.range.startsWith("exec:")){let u=H(y.range);return!u||!u.parentLocator?void 0:{parentLocator:u.parentLocator,paths:[u.path]}}else if(y.range.startsWith("patch:")){let{parentLocator:u,patchPaths:Q}=K.patchUtils.parseDescriptor(y);return u?{parentLocator:u,paths:Q}:void 0}}}),await S({destination:c,project:o,cache:a,report:s}),await B({destination:c,project:o,report:s}),(f=this.copyManifestFiles)!=null&&f.length&&await C({destination:c,files:this.copyManifestFiles,buildDir:p,report:s})});for(let f of i){let y=f.manifest.name?d.structUtils.stringifyIdent(f.manifest.name):"";await s.startTimerPromise(`Pack workspace ${y}`,async()=>{await V({workspace:f,report:s,destination:b,manifestDir:c})})}(R=this.copyPackFiles)!=null&&R.length&&await C({destination:b,files:this.copyPackFiles,buildDir:p,report:s})})).exitCode()}};I(x,"usage",g.Command.Usage({category:"Docker-related commands",description:"Pack a workspace for Docker",details:`
      This command will pack a build dir which only contains required dependencies for the specified workspace.

      You can copy additional files or folders using the "--copy-pack/manifest" option. This is useful for secret keys or configuration files. The files will be copied to either the "manifests" or "packs" folders. The path can be either a path relative to the build dir or an absolute path.
    `,examples:[["Pack a workspace for Docker","yarn docker pack @foo/bar"],["Copy additional files","yarn docker pack --copy-pack secret.key --copy-manifest config.json @foo/bar"]]})),I(x,"paths",[["docker","pack"]]);var ct={commands:[x]},pt=ct;return at(lt);})();
return plugin;
}
};
