/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-docker",
factory: function (require) {
var plugin=(()=>{var tt=Object.create,C=Object.defineProperty;var ot=Object.getOwnPropertyDescriptor;var et=Object.getOwnPropertyNames;var rt=Object.getPrototypeOf,it=Object.prototype.hasOwnProperty;var at=t=>C(t,"__esModule",{value:!0});var n=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var st=(t,e)=>{for(var o in e)C(t,o,{get:e[o],enumerable:!0})},nt=(t,e,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of et(e))!it.call(t,r)&&r!=="default"&&C(t,r,{get:()=>e[r],enumerable:!(o=ot(e,r))||o.enumerable});return t},c=t=>nt(at(C(t!=null?tt(rt(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var mt={};st(mt,{default:()=>ft});var X=c(n("@yarnpkg/cli")),d=c(n("@yarnpkg/core")),u=c(n("@yarnpkg/fslib")),K=c(n("@yarnpkg/plugin-patch")),b=c(n("clipanion"));var h=c(n("@yarnpkg/fslib"));function ct(t,e){let o=h.npath.toPortablePath(e);return h.ppath.isAbsolute(o)?h.ppath.relative(t,o):o}async function I({destination:t,files:e,buildDir:o,report:r}){let i=h.ppath.dirname(o);for(let a of e){let f=ct(i,a),s=h.ppath.join(i,f),l=h.ppath.join(t,f);r.reportInfo(null,f),await h.xfs.copyPromise(l,s)}}var v=c(n("@yarnpkg/fslib")),$=c(n("@yarnpkg/core"));async function M({destination:t,project:e,cache:o,report:r}){for(let i of o.markedFiles){let a=v.ppath.relative(e.cwd,i);await v.xfs.existsPromise(i)?(r.reportInfo(null,a),await v.xfs.copyPromise(v.ppath.join(t,a),i)):r.reportWarning($.MessageName.UNUSED_CACHE_ENTRY,a)}}var x=c(n("@yarnpkg/fslib")),z=c(n("@yarnpkg/core"));async function S({destination:t,workspaces:e,report:o}){for(let r of e){let i=x.ppath.join(r.relativeCwd,z.Manifest.fileName),a=x.ppath.join(t,i),f={};r.manifest.exportTo(f),o.reportInfo(null,i),await x.xfs.mkdirpPromise(x.ppath.dirname(a)),await x.xfs.writeJsonPromise(a,f)}}var y=c(n("@yarnpkg/fslib"));async function T({destination:t,project:e,report:o}){let r=y.ppath.join((0,y.toFilename)(".yarn"),(0,y.toFilename)("plugins"));o.reportInfo(null,r),await y.xfs.copyPromise(y.ppath.join(t,r),y.ppath.join(e.cwd,r),{overwrite:!0})}var U=c(n("@yarnpkg/core")),k=c(n("@yarnpkg/fslib")),pt=/^builtin<([^>]+)>$/;async function A({destination:t,report:e,project:o,parseDescriptor:r}){let i=new Set;for(let a of o.storedDescriptors.values()){let f=U.structUtils.isVirtualDescriptor(a)?U.structUtils.devirtualizeDescriptor(a):a,s=r(f);if(!s)continue;let{parentLocator:l,paths:p}=s;for(let j of p){if(pt.test(j)||k.ppath.isAbsolute(j))continue;let R=o.getWorkspaceByLocator(l),m=k.ppath.join(R.relativeCwd,j);if(i.has(m))continue;i.add(m);let g=k.ppath.join(R.cwd,j),P=k.ppath.join(t,m);e.reportInfo(null,m),await k.xfs.mkdirpPromise(k.ppath.dirname(P)),await k.xfs.copyFilePromise(g,P)}}}var F=c(n("@yarnpkg/fslib"));async function q({destination:t,project:e,report:o}){let r=e.configuration.get("rcFilename");o.reportInfo(null,r),await F.xfs.copyPromise(F.ppath.join(t,r),F.ppath.join(e.cwd,r),{overwrite:!0})}var D=c(n("@yarnpkg/fslib"));async function E({destination:t,project:e,report:o}){let r=e.configuration.get("yarnPath"),i=D.ppath.relative(e.cwd,r),a=D.ppath.join(t,i);o.reportInfo(null,i),await D.xfs.copyPromise(a,r,{overwrite:!0})}var N=c(n("@yarnpkg/core")),G=c(n("@yarnpkg/fslib"));function H(t){let{params:e,selector:o}=N.structUtils.parseRange(t),r=G.npath.toPortablePath(o);return{parentLocator:e&&typeof e.locator=="string"?N.structUtils.parseLocator(e.locator):null,path:r}}var w=c(n("@yarnpkg/fslib"));async function B({destination:t,project:e,report:o}){let r=(0,w.toFilename)(e.configuration.get("lockfileFilename")),i=w.ppath.join(t,r);o.reportInfo(null,r),await w.xfs.mkdirpPromise(w.ppath.dirname(i)),await w.xfs.writeFilePromise(i,e.generateLockfile())}var J=c(n("@yarnpkg/core"));function Y({project:t,workspaces:e,production:o=!1,scopes:r=o?["dependencies"]:J.Manifest.hardDependencies}){let i=new Set([...e]);for(let a of i)for(let f of r){let s=a.manifest.getForScope(f).values();for(let l of s){let p=t.tryWorkspaceByDescriptor(l);p&&i.add(p)}}for(let a of t.workspaces)i.has(a)?o&&a.manifest.devDependencies.clear():(a.manifest.dependencies.clear(),a.manifest.devDependencies.clear(),a.manifest.peerDependencies.clear());return i}var O=c(n("@yarnpkg/core")),W=c(n("@yarnpkg/fslib")),_=c(n("@yarnpkg/plugin-pack"));async function V({workspace:t,destination:e,manifestDir:o,report:r}){await _.packUtils.prepareForPack(t,{report:r},async()=>{let i=await _.packUtils.genPackList(t),a=O.Report.progressViaCounter(i.length),f=r.reportProgress(a);try{for(let s of i){let l=W.ppath.join(t.cwd,s);if(l.startsWith(o))continue;let p=W.ppath.join(e,t.relativeCwd,s);r.reportInfo(null,s),await W.xfs.copyPromise(p,l,{overwrite:!0}),a.tick()}}finally{f.stop()}})}var L=class extends X.BaseCommand{constructor(){super(...arguments);this.workspaceName=b.Option.String();this.buildDir=b.Option.String("-d,--dir","build");this.copyPackFiles=b.Option.Array("-cp,--copy-pack");this.copyManifestFiles=b.Option.Array("-cm,--copy-manifest");this.production=b.Option.Boolean("-p,--production")}async execute(){let e=await d.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await d.Project.find(e,this.context.cwd),r=o.getWorkspaceByIdent(d.structUtils.parseIdent(this.workspaceName)),i=Y({project:o,workspaces:[r],production:this.production}),a=await d.Cache.find(e);return(await d.StreamReport.start({configuration:e,stdout:this.context.stdout,includeLogs:!this.context.quiet},async s=>{var R;await s.startTimerPromise("Resolution Step",async()=>{await o.resolveEverything({report:s,cache:a})}),await s.startTimerPromise("Fetch Step",async()=>{await o.fetchEverything({report:s,cache:a})});let l=u.ppath.join(this.context.cwd,u.npath.toPortablePath(this.buildDir));await s.startTimerPromise("Remove previous build",async()=>{await u.xfs.removePromise(l,{recursive:!0})});let p=u.ppath.join(l,(0,u.toFilename)("manifests")),j=u.ppath.join(l,(0,u.toFilename)("packs"));await s.startTimerPromise("Copy files",async()=>{var m;await q({destination:p,project:o,report:s}),await T({destination:p,project:o,report:s}),await E({destination:p,project:o,report:s}),await S({destination:p,workspaces:o.workspaces,report:s}),await A({destination:p,report:s,project:o,parseDescriptor:g=>{if(g.range.startsWith("exec:")){let P=H(g.range);return!P||!P.parentLocator?void 0:{parentLocator:P.parentLocator,paths:[P.path]}}else if(g.range.startsWith("patch:")){let{parentLocator:P,patchPaths:Z}=K.patchUtils.parseDescriptor(g);return P?{parentLocator:P,paths:Z}:void 0}}}),await M({destination:p,project:o,cache:a,report:s}),await B({destination:p,project:o,report:s}),((m=this.copyManifestFiles)==null?void 0:m.length)&&await I({destination:p,files:this.copyManifestFiles,buildDir:l,report:s})});for(let m of i){let g=m.manifest.name?d.structUtils.stringifyIdent(m.manifest.name):"";await s.startTimerPromise(`Pack workspace ${g}`,async()=>{await V({workspace:m,report:s,destination:j,manifestDir:p})})}((R=this.copyPackFiles)==null?void 0:R.length)&&await I({destination:j,files:this.copyPackFiles,buildDir:l,report:s})})).exitCode()}};L.usage=b.Command.Usage({category:"Docker-related commands",description:"Pack a workspace for Docker",details:`
      This command will pack a build dir which only contains required dependencies for the specified workspace.

      You can copy additional files or folders using the "--copy-pack/manifest" option. This is useful for secret keys or configuration files. The files will be copied to either the "manifests" or "packs" folders. The path can be either a path relative to the build dir or an absolute path.
    `,examples:[["Pack a workspace for Docker","yarn docker pack @foo/bar"],["Copy additional files","yarn docker pack --copy-pack secret.key --copy-manifest config.json @foo/bar"]]}),L.paths=[["docker","pack"]];var Q=L;var lt={commands:[Q]},ft=lt;return mt;})();
return plugin;
}
};
