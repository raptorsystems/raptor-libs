/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-docker",
factory: function (require) {
"use strict";var plugin=(()=>{var I=Object.defineProperty;var Z=Object.getOwnPropertyDescriptor;var tt=Object.getOwnPropertyNames;var ot=Object.prototype.hasOwnProperty;var n=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+o+'" is not supported')});var et=(o,e)=>{for(var r in e)I(o,r,{get:e[r],enumerable:!0})},rt=(o,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of tt(e))!ot.call(o,i)&&i!==r&&I(o,i,{get:()=>e[i],enumerable:!(t=Z(e,i))||t.enumerable});return o};var it=o=>rt(I({},"__esModule",{value:!0}),o);var pt={};et(pt,{default:()=>ct});var X=n("@yarnpkg/cli"),d=n("@yarnpkg/core"),m=n("@yarnpkg/fslib"),K=n("@yarnpkg/plugin-patch"),g=n("clipanion");var u=n("@yarnpkg/fslib");function at(o,e){let r=u.npath.toPortablePath(e);return u.ppath.isAbsolute(r)?u.ppath.relative(o,r):r}async function C({destination:o,files:e,buildDir:r,report:t}){let i=u.ppath.dirname(r);for(let a of e){let c=at(i,a),f=u.ppath.join(i,c),s=u.ppath.join(o,c);t.reportInfo(null,c),await u.xfs.copyPromise(s,f)}}var R=n("@yarnpkg/fslib"),$=n("@yarnpkg/core");async function S({destination:o,project:e,cache:r,report:t}){for(let i of r.markedFiles){let a=R.ppath.relative(e.cwd,i);await R.xfs.existsPromise(i)?(t.reportInfo(null,a),await R.xfs.copyPromise(R.ppath.join(o,a),i)):t.reportWarning($.MessageName.UNUSED_CACHE_ENTRY,a)}}var x=n("@yarnpkg/fslib"),z=n("@yarnpkg/core");async function T({destination:o,workspaces:e,report:r}){for(let t of e){let i=x.ppath.join(t.relativeCwd,z.Manifest.fileName),a=x.ppath.join(o,i),c={};t.manifest.exportTo(c),r.reportInfo(null,i),await x.xfs.mkdirpPromise(x.ppath.dirname(a)),await x.xfs.writeJsonPromise(a,c)}}var h=n("@yarnpkg/fslib");async function M({destination:o,project:e,report:r}){let t=h.ppath.join((0,h.toFilename)(".yarn"),(0,h.toFilename)("plugins"));r.reportInfo(null,t),await h.xfs.copyPromise(h.ppath.join(o,t),h.ppath.join(e.cwd,t),{overwrite:!0})}var U=n("@yarnpkg/core"),w=n("@yarnpkg/fslib"),st=/^builtin<([^>]+)>$/;async function A({destination:o,report:e,project:r,parseDescriptor:t}){let i=new Set;for(let a of r.storedDescriptors.values()){let c=U.structUtils.isVirtualDescriptor(a)?U.structUtils.devirtualizeDescriptor(a):a,f=t(c);if(!f)continue;let{parentLocator:s,paths:l}=f;for(let p of l){if(st.test(p)||w.ppath.isAbsolute(p))continue;let D=r.getWorkspaceByLocator(s),b=w.ppath.join(D.relativeCwd,p);if(i.has(b))continue;i.add(b);let y=w.ppath.join(D.cwd,p),P=w.ppath.join(o,b);e.reportInfo(null,b),await w.xfs.mkdirpPromise(w.ppath.dirname(P)),await w.xfs.copyFilePromise(y,P)}}}var F=n("@yarnpkg/fslib");async function E({destination:o,project:e,report:r}){let t=e.configuration.get("rcFilename");r.reportInfo(null,t),await F.xfs.copyPromise(F.ppath.join(o,t),F.ppath.join(e.cwd,t),{overwrite:!0})}var L=n("@yarnpkg/fslib");async function N({destination:o,project:e,report:r}){let t=e.configuration.get("yarnPath"),i=L.ppath.relative(e.cwd,t),a=L.ppath.join(o,i);r.reportInfo(null,i),await L.xfs.copyPromise(a,t,{overwrite:!0})}var q=n("@yarnpkg/core"),G=n("@yarnpkg/fslib");function H(o){let{params:e,selector:r}=q.structUtils.parseRange(o),t=G.npath.toPortablePath(r);return{parentLocator:e&&typeof e.locator=="string"?q.structUtils.parseLocator(e.locator):null,path:t}}var k=n("@yarnpkg/fslib");async function B({destination:o,project:e,report:r}){let t=(0,k.toFilename)(e.configuration.get("lockfileFilename")),i=k.ppath.join(o,t);r.reportInfo(null,t),await k.xfs.mkdirpPromise(k.ppath.dirname(i)),await k.xfs.writeFilePromise(i,e.generateLockfile())}var J=n("@yarnpkg/core");function Y({project:o,workspaces:e,production:r=!1,scopes:t=r?["dependencies"]:J.Manifest.hardDependencies}){let i=new Set([...e]);for(let a of i)for(let c of t){let f=a.manifest.getForScope(c).values();for(let s of f){let l=o.tryWorkspaceByDescriptor(s);l&&i.add(l)}}for(let a of o.workspaces)i.has(a)?r&&a.manifest.devDependencies.clear():(a.manifest.dependencies.clear(),a.manifest.devDependencies.clear(),a.manifest.peerDependencies.clear());return i}var O=n("@yarnpkg/core"),W=n("@yarnpkg/fslib"),_=n("@yarnpkg/plugin-pack");async function V({workspace:o,destination:e,manifestDir:r,report:t}){await _.packUtils.prepareForPack(o,{report:t},async()=>{let i=await _.packUtils.genPackList(o),a=O.Report.progressViaCounter(i.length),c=t.reportProgress(a);try{for(let f of i){let s=W.ppath.join(o.cwd,f);if(s.startsWith(r))continue;let l=W.ppath.join(e,o.relativeCwd,f);t.reportInfo(null,f),await W.xfs.copyPromise(l,s,{overwrite:!0}),a.tick()}}finally{c.stop()}})}var v=class extends X.BaseCommand{constructor(){super(...arguments);this.workspaceName=g.Option.String();this.buildDir=g.Option.String("-d,--dir","build");this.copyPackFiles=g.Option.Array("-cp,--copy-pack");this.copyManifestFiles=g.Option.Array("-cm,--copy-manifest");this.production=g.Option.Boolean("-p,--production")}async execute(){let r=await d.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await d.Project.find(r,this.context.cwd),i=t.getWorkspaceByIdent(d.structUtils.parseIdent(this.workspaceName)),a=Y({project:t,workspaces:[i],production:this.production}),c=await d.Cache.find(r);return(await d.StreamReport.start({configuration:r,stdout:this.context.stdout,includeLogs:!this.context.quiet},async s=>{var b;await s.startTimerPromise("Resolution Step",async()=>{await t.resolveEverything({report:s,cache:c})}),await s.startTimerPromise("Fetch Step",async()=>{await t.fetchEverything({report:s,cache:c})});let l=m.ppath.join(this.context.cwd,m.npath.toPortablePath(this.buildDir));await s.startTimerPromise("Remove previous build",async()=>{await m.xfs.removePromise(l,{recursive:!0})});let p=m.ppath.join(l,(0,m.toFilename)("manifests")),D=m.ppath.join(l,(0,m.toFilename)("packs"));await s.startTimerPromise("Copy files",async()=>{var y;await E({destination:p,project:t,report:s}),await M({destination:p,project:t,report:s}),await N({destination:p,project:t,report:s}),await T({destination:p,workspaces:t.workspaces,report:s}),await A({destination:p,report:s,project:t,parseDescriptor:P=>{if(P.range.startsWith("exec:")){let j=H(P.range);return!j||!j.parentLocator?void 0:{parentLocator:j.parentLocator,paths:[j.path]}}else if(P.range.startsWith("patch:")){let{parentLocator:j,patchPaths:Q}=K.patchUtils.parseDescriptor(P);return j?{parentLocator:j,paths:Q}:void 0}}}),await S({destination:p,project:t,cache:c,report:s}),await B({destination:p,project:t,report:s}),(y=this.copyManifestFiles)!=null&&y.length&&await C({destination:p,files:this.copyManifestFiles,buildDir:l,report:s})});for(let y of a){let P=y.manifest.name?d.structUtils.stringifyIdent(y.manifest.name):"";await s.startTimerPromise(`Pack workspace ${P}`,async()=>{await V({workspace:y,report:s,destination:D,manifestDir:p})})}(b=this.copyPackFiles)!=null&&b.length&&await C({destination:D,files:this.copyPackFiles,buildDir:l,report:s})})).exitCode()}};v.usage=g.Command.Usage({category:"Docker-related commands",description:"Pack a workspace for Docker",details:`
      This command will pack a build dir which only contains required dependencies for the specified workspace.

      You can copy additional files or folders using the "--copy-pack/manifest" option. This is useful for secret keys or configuration files. The files will be copied to either the "manifests" or "packs" folders. The path can be either a path relative to the build dir or an absolute path.
    `,examples:[["Pack a workspace for Docker","yarn docker pack @foo/bar"],["Copy additional files","yarn docker pack --copy-pack secret.key --copy-manifest config.json @foo/bar"]]}),v.paths=[["docker","pack"]];var nt={commands:[v]},ct=nt;return it(pt);})();
return plugin;
}
};
