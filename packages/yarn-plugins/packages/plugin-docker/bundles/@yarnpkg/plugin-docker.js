/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-docker",
factory: function (require) {
"use strict";var plugin=(()=>{var M=Object.defineProperty;var at=Object.getOwnPropertyDescriptor;var st=Object.getOwnPropertyNames;var nt=Object.prototype.hasOwnProperty;var n=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+o+'" is not supported')});var ct=(o,e)=>{for(var r in e)M(o,r,{get:e[r],enumerable:!0})},pt=(o,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of st(e))!nt.call(o,i)&&i!==r&&M(o,i,{get:()=>e[i],enumerable:!(t=at(e,i))||t.enumerable});return o};var lt=o=>pt(M({},"__esModule",{value:!0}),o);var ht={};ct(ht,{default:()=>Pt});var ot=n("@yarnpkg/cli"),f=n("@yarnpkg/core"),et=n("@yarnpkg/fslib"),y=n("@yarnpkg/fslib"),rt=n("@yarnpkg/plugin-patch");var D=n("@yarnpkg/fslib");async function A({destination:o,dockerFilePath:e,report:r}){let t=e,i=D.ppath.join(o,(0,D.toFilename)("Dockerfile"));r.reportInfo(null,t),await D.xfs.copyPromise(i,t,{overwrite:!0})}var g=n("@yarnpkg/fslib");async function U(o,e="Dockerfile"){let r=(0,g.toFilename)(e);if(g.ppath.isAbsolute(r))return r;let t=[g.ppath.join(o.cwd,r),g.ppath.join(o.project.cwd,r)];for(let i of t)if(await g.xfs.existsPromise(i))return i;throw new Error("Dockerfile is required")}var k=n("clipanion");var m=n("@yarnpkg/fslib");function ft(o,e){let r=m.npath.toPortablePath(e);return m.ppath.isAbsolute(r)?m.ppath.relative(o,r):r}async function T({destination:o,files:e,dockerFilePath:r,report:t}){let i=m.ppath.dirname(r);for(let a of e){let c=ft(i,a),p=m.ppath.join(i,c),d=m.ppath.join(o,c);t.reportInfo(null,c),await m.xfs.copyPromise(d,p)}}var W=n("@yarnpkg/fslib"),O=n("@yarnpkg/core");async function E({destination:o,project:e,cache:r,report:t}){for(let i of r.markedFiles){let a=W.ppath.relative(e.cwd,i);await W.xfs.existsPromise(i)?(t.reportInfo(null,a),await W.xfs.copyPromise(W.ppath.join(o,a),i)):t.reportWarning(O.MessageName.UNUSED_CACHE_ENTRY,a)}}var v=n("@yarnpkg/fslib"),X=n("@yarnpkg/core");async function q({destination:o,workspaces:e,report:r}){for(let t of e){let i=v.ppath.join(t.relativeCwd,X.Manifest.fileName),a=v.ppath.join(o,i),c={};t.manifest.exportTo(c),r.reportInfo(null,i),await v.xfs.mkdirpPromise(v.ppath.dirname(a)),await v.xfs.writeJsonPromise(a,c)}}var u=n("@yarnpkg/fslib");async function N({destination:o,project:e,report:r}){let t=u.ppath.join((0,u.toFilename)(".yarn"),(0,u.toFilename)("plugins"));r.reportInfo(null,t),await u.xfs.copyPromise(u.ppath.join(o,t),u.ppath.join(e.cwd,t),{overwrite:!0})}var B=n("@yarnpkg/core"),w=n("@yarnpkg/fslib"),mt=/^builtin<([^>]+)>$/;async function Y({destination:o,report:e,project:r,parseDescriptor:t}){let i=new Set;for(let a of r.storedDescriptors.values()){let c=B.structUtils.isVirtualDescriptor(a)?B.structUtils.devirtualizeDescriptor(a):a,p=t(c);if(!p)continue;let{parentLocator:d,paths:s}=p;for(let P of s){if(mt.test(P)||w.ppath.isAbsolute(P))continue;let l=r.getWorkspaceByLocator(d),j=w.ppath.join(l.relativeCwd,P);if(i.has(j))continue;i.add(j);let S=w.ppath.join(l.cwd,P),h=w.ppath.join(o,j);e.reportInfo(null,j),await w.xfs.mkdirpPromise(w.ppath.dirname(h)),await w.xfs.copyFilePromise(S,h)}}}var L=n("@yarnpkg/fslib");async function _({destination:o,project:e,report:r}){let t=e.configuration.get("rcFilename");r.reportInfo(null,t),await L.xfs.copyPromise(L.ppath.join(o,t),L.ppath.join(e.cwd,t),{overwrite:!0})}var I=n("@yarnpkg/fslib");async function V({destination:o,project:e,report:r}){let t=e.configuration.get("yarnPath"),i=I.ppath.relative(e.cwd,t),a=I.ppath.join(o,i);r.reportInfo(null,i),await I.xfs.copyPromise(a,t,{overwrite:!0})}var $=n("@yarnpkg/core"),K=n("@yarnpkg/fslib");function Q(o){let{params:e,selector:r}=$.structUtils.parseRange(o),t=K.npath.toPortablePath(r);return{parentLocator:e&&typeof e.locator=="string"?$.structUtils.parseLocator(e.locator):null,path:t}}var b=n("@yarnpkg/fslib");async function z({destination:o,project:e,report:r}){let t=(0,b.toFilename)(e.configuration.get("lockfileFilename")),i=b.ppath.join(o,t);r.reportInfo(null,t),await b.xfs.mkdirpPromise(b.ppath.dirname(i)),await b.xfs.writeFilePromise(i,e.generateLockfile())}var Z=n("@yarnpkg/core");function G({project:o,workspaces:e,production:r=!1,scopes:t=r?["dependencies"]:Z.Manifest.hardDependencies}){let i=new Set([...e]);for(let a of i)for(let c of t){let p=a.manifest.getForScope(c).values();for(let d of p){let s=o.tryWorkspaceByDescriptor(d);s&&i.add(s)}}for(let a of o.workspaces)i.has(a)?r&&a.manifest.devDependencies.clear():(a.manifest.dependencies.clear(),a.manifest.devDependencies.clear(),a.manifest.peerDependencies.clear());return i}var tt=n("@yarnpkg/core"),C=n("@yarnpkg/fslib"),H=n("@yarnpkg/plugin-pack");async function J({workspace:o,destination:e,manifestDir:r,report:t}){await H.packUtils.prepareForPack(o,{report:t},async()=>{let i=await H.packUtils.genPackList(o),a=tt.Report.progressViaCounter(i.length),c=t.reportProgress(a);try{for(let p of i){let d=C.ppath.join(o.cwd,p);if(d.startsWith(r))continue;let s=C.ppath.join(e,o.relativeCwd,p);t.reportInfo(null,p),await C.xfs.copyPromise(s,d,{overwrite:!0}),a.tick()}}finally{c.stop()}})}var F=class extends ot.BaseCommand{constructor(){super(...arguments);this.workspaceName=k.Option.String();this.dockerFilePath=k.Option.String("-f,--file");this.buildDir=k.Option.String("-d,--dir","build");this.copyPackFiles=k.Option.Array("-cp,--copy-pack");this.copyManifestFiles=k.Option.Array("-cm,--copy-manifest");this.production=k.Option.Boolean("-p,--production")}async execute(){let r=await f.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await f.Project.find(r,this.context.cwd),i=t.getWorkspaceByIdent(f.structUtils.parseIdent(this.workspaceName)),a=G({project:t,workspaces:[i],production:this.production}),c=await U(i,this.dockerFilePath),p=await f.Cache.find(r);return(await f.StreamReport.start({configuration:r,stdout:this.context.stdout,includeLogs:!this.context.quiet},async s=>{var S;await s.startTimerPromise("Resolution Step",async()=>{await t.resolveEverything({report:s,cache:p})}),await s.startTimerPromise("Fetch Step",async()=>{await t.fetchEverything({report:s,cache:p})});let P=y.ppath.join(this.context.cwd,y.npath.toPortablePath(this.buildDir));await s.startTimerPromise("Remove previous build",async()=>{await et.xfs.removePromise(P,{recursive:!0})});let l=y.ppath.join(P,(0,y.toFilename)("manifests")),j=y.ppath.join(P,(0,y.toFilename)("packs"));await s.startTimerPromise("Copy files",async()=>{var h;await _({destination:l,project:t,report:s}),await N({destination:l,project:t,report:s}),await V({destination:l,project:t,report:s}),await q({destination:l,workspaces:t.workspaces,report:s}),await Y({destination:l,report:s,project:t,parseDescriptor:R=>{if(R.range.startsWith("exec:")){let x=Q(R.range);return!x||!x.parentLocator?void 0:{parentLocator:x.parentLocator,paths:[x.path]}}else if(R.range.startsWith("patch:")){let{parentLocator:x,patchPaths:it}=rt.patchUtils.parseDescriptor(R);return x?{parentLocator:x,paths:it}:void 0}}}),await E({destination:l,project:t,cache:p,report:s}),await z({destination:l,project:t,report:s}),(h=this.copyManifestFiles)!=null&&h.length&&await T({destination:l,files:this.copyManifestFiles,dockerFilePath:c,report:s})});for(let h of a){let R=h.manifest.name?f.structUtils.stringifyIdent(h.manifest.name):"";await s.startTimerPromise(`Pack workspace ${R}`,async()=>{await J({workspace:h,report:s,destination:j,manifestDir:l})})}(S=this.copyPackFiles)!=null&&S.length&&await T({destination:j,files:this.copyPackFiles,dockerFilePath:c,report:s}),await A({destination:P,dockerFilePath:c,report:s})})).exitCode()}};F.usage=k.Command.Usage({category:"Docker-related commands",description:"Pack a workspace for Docker",details:`
      This command will pack a build dir which only contains required dependencies for the specified workspace.

      You can copy additional files or folders using the "--copy-pack/manifest" option. This is useful for secret keys or configuration files. The files will be copied to either the "manifests" or "packs" folders. The path can be either a path relative to the Dockerfile or an absolute path.
    `,examples:[["Pack a workspace for Docker","yarn docker pack @foo/bar"],["Copy additional files","yarn docker pack --copy-pack secret.key --copy-manifest config.json @foo/bar"]]}),F.paths=[["docker","pack"]];var dt={commands:[F]},Pt=dt;return lt(ht);})();
return plugin;
}
};
